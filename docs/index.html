<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Blob Analyze Lab Demo</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
</head>
<body>
<div class="container-fluid vh-100">
    <nav class="row navbar bg-light">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1">Blob Lab Demo</span>
        </div>
    </nav>

    <!--<div class="container-fluid">-->
    <div class="row h-100">
        <div class="col overflow-hidden">
            <canvas id="bl-canvas" class="h-100 w-100" resize oncontextmenu="return false;"></canvas>
        </div>
        <div class="col-md-4 border-2">
            <div class="mb-3">
                <div class="card mb-2">
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="bl-picture-file" class="form-label"><span class="badge rounded-pill text-bg-primary">1</span> Charger une photo de blob</label>
                            <input class="form-control" type="file" id="bl-picture-file">
                        </div>

                    </div>
                </div>

                <div class="card mb-2">
                    <div class="card-body">
                        <p><span class="badge rounded-pill text-bg-primary">2</span>
                            Shift + Roulette : zoomer. Shift + Click : déplacer la photographie.</p>
                        <button id="bl-fit-view" type="button" class="btn btn-primary">Recentrer</button>
                        <button id="bl-reset-view" type="button" class="btn btn-primary">1:1</button>
                    </div>
                </div>
                <div class="card mb-2">
                    <div class="card-body">
                        <p><span class="badge rounded-pill text-bg-primary">3</span> Ajuster la règle (couvrir 9 cm).</p>
                        <span class="text-muted">Résolution : <span id="bl-resolution">...</span> pixels par cm².</span>
                    </div>
                </div>
                <div class="card mb-2">
                    <div class="card-body">
                        <p><span class="badge rounded-pill text-bg-primary">4</span> Entourer le blob en dessinant avec la souris.</p>
                        <p class="text-muted">Aire du blob : <span id="bl-area">...</span> cm².</p>
                        <button id="bl-undo-blob" type="button" class="btn btn-primary">Défaire</button>
                        <button id="bl-clear-blob" type="button" class="btn btn-primary">Effacer tout</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!--</div>-->

</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous"></script>
<script src="js/paper-full.js"></script>
<script>

    function Ruler(raster) {
        let that = this;
        this.handleCircle1 = new paper.Path.Circle(new Point(raster.position.x - raster.image.naturalWidth * 0.4, raster.position.y), 20);
        this.handleCircle1.fillColor = "red";
        this.handleCircle2 = new paper.Path.Circle(new Point(raster.position.x + raster.image.naturalWidth * 0.4, raster.position.y), 20);
        this.handleCircle2.fillColor = "red";
        let onMouseDrag = function(event) {
            event.target.position = event.target.position.add(event.delta);
            that.redraw();
        }
        this.handleCircle1.onMouseDrag = onMouseDrag;
        this.handleCircle2.onMouseDrag = onMouseDrag;
        this.rulerGroup = new paper.Group();
        this.tickCount = 9;
        this.resolution = NaN;
        this.clear = function () {
            this.handleCircle1.remove();
            this.handleCircle2.remove();
            this.rulerGroup.remove();
        };
        this.redraw = function () {
            this.rulerGroup.remove();
            this.rulerGroup = new paper.Group();
            let mainLine = new paper.Path.Line(this.handleCircle1.position, this.handleCircle2.position);
            this.rulerGroup.addChild(mainLine);

            let vector = this.handleCircle2.position.subtract(this.handleCircle1.position);
            for (let i = 1; i < this.tickCount; i++) {
                let tickCircle = new paper.Path.Circle(this.handleCircle1.position.add(vector.multiply(i / this.tickCount)), 10);
                this.rulerGroup.addChild(tickCircle);
            }
            this.rulerGroup.strokeWidth = 5;
            this.rulerGroup.strokeColor = 'red';
            this.resolution = Math.pow(vector.length / this.tickCount, 2);
            paper.view.draw();
            this.onChange();
        };
        this.onChange = function() { };
        this.redraw();
    };

    // Only executed our code once the DOM is ready.
    window.onload = function() {
        // Get a reference to the canvas object
        let canvas = document.getElementById('bl-canvas');

        // Create an empty project and a view for the canvas:
        paper.install(window);
        paper.setup(canvas);

        let tool = new Tool();

        // Contient la photo
        let raster = null;

        // Blob path
        let blobPath = null;

        // La règle
        let ruler = null;

        // Recentrer la vue
        let fitWiew = function () {
            paper.view.center = raster.position;
            let xZoomFactor = Math.min(1, canvas.width / raster.image.naturalWidth);
            let yZoomFactor = Math.min(1, canvas.height / raster.image.naturalHeight);
            paper.view.zoom = Math.min(xZoomFactor, yZoomFactor);
            paper.view.draw();
        }

        // Taille 1:1
        let resetView = function () {
            paper.view.center = raster.position;
            paper.view.zoom = 1.0;
            paper.view.draw();
        }

        let undoBlobPath = function () {
            if(blobPath != null && blobPath.segments.length > 0) {
                blobPath.removeSegments(Math.max(blobPath.segments.length - 5, 0));
            }
        }

        let updateMeasures = function () {
            document.getElementById("bl-resolution").innerText = ruler.resolution;
            document.getElementById("bl-area").innerText = (blobPath.area / ruler.resolution).toString();
        }

        // Ajout de l'interactivité

        document.getElementById("bl-fit-view").addEventListener("click",  (event) => {
            fitWiew();
        });
        document.getElementById("bl-reset-view").addEventListener("click",  (event) => {
            resetView();
        });
        document.getElementById("bl-clear-blob").addEventListener("click",  (event) => {
            if(blobPath != null) {
                blobPath.removeSegments();
            }
        });
        document.getElementById("bl-undo-blob").addEventListener("click",  (event) => {
            undoBlobPath();
        });

        document.getElementById("bl-canvas").addEventListener('wheel', (event) => {
            var newZoom = paper.view.zoom;
            var oldZoom = paper.view.zoom;

            if (event.deltaY > 0) {
                newZoom = paper.view.zoom * 0.95;
            } else {
                newZoom = paper.view.zoom * 1.05;
            }

            var beta = oldZoom / newZoom;

            var mousePosition = new paper.Point(event.offsetX, event.offsetY);

            //viewToProject: gives the coordinates in the Project space from the Screen Coordinates
            var viewPosition = paper.view.viewToProject(mousePosition);

            var mpos = viewPosition;
            var ctr = paper.view.center;

            var pc = mpos.subtract(ctr);
            var offset = mpos.subtract(pc.multiply(beta)).subtract(ctr);

            paper.view.zoom = newZoom;
            paper.view.center = paper.view.center.add(offset);

            event.preventDefault();
            paper.view.draw();
        });

        tool.onMouseDrag = function(event) {
            if(event.modifiers.shift) { // SHIFT => déplacer la photo
                var pan_offset = event.point.subtract(event.downPoint);
                paper.view.center = paper.view.center.subtract(pan_offset);
            }
            event.preventDefault();
        }


        document.getElementById("bl-picture-file").onchange = (e) => {
            const img = new Image();
            img.src = URL.createObjectURL(e.target.files[0]);
            img.onload = function () {
                if(raster != null) {
                    raster.remove();
                }
                raster = new paper.Raster();
                raster.image = img;
                raster.bounds.point = new paper.Point(0, 0);
                raster.smoothing = 'off';

                if(blobPath != null) {
                    blobPath.remove();
                }
                blobPath = new paper.Path();
                blobPath.strokeColor = "yellow";
                blobPath.strokeWidth = 5;
                raster.onMouseDrag = function (event) {
                    if (!event.modifiers.shift) { // Epêche de dessiner lors du déplacement de la vue
                        blobPath.add(event.point);
                        blobPath.smooth({ type: 'continuous' });
                        updateMeasures();
                    }
                }
                fitWiew();
                ruler = new Ruler(raster);
                ruler.onChange = function() {
                    updateMeasures();
                }
                updateMeasures();
            }
        };


    }

</script>

</body>
</html>